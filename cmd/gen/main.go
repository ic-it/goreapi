package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"os"
	"os/exec"
	"strings"
	"text/template"
)

const (
	inputFile  = "cmd/web/handlers.go"
	outputFile = "cmd/web/handlers-generated.go"
)

func displayExpr(expr ast.Expr) {
	if expr == nil {
		return
	}
	file, _ := os.ReadFile(inputFile)
	text := file[expr.Pos()-1 : expr.End()-1]
	fmt.Printf("%s\n", text)
}

func displayNode(node ast.Node) {
	if node == nil {
		return
	}
	file, _ := os.ReadFile(inputFile)
	text := file[node.Pos()-1 : node.End()-1]
	fmt.Printf("%s\n", text)
}

func getNodeAsString(node ast.Node) string {
	if node == nil {
		return ""
	}
	file, _ := os.ReadFile(inputFile)
	text := file[node.Pos()-1 : node.End()-1]
	return string(text)
}

func main() {
	node := ReadFile(inputFile)

	handlerDeclarations := GetHandlerDeclarations(node)
	for _, declf := range handlerDeclarations {
		name := declf.name
		decl := declf.node
		params := GetNameType(decl, GOREAPI_PARAM)
		for _, param := range params {
			fmt.Printf("Param: %s %v\n", param.Name, param.Type)
		}
		queries := GetNameType(decl, GOREAPI_QUERY)
		for _, query := range queries {
			fmt.Printf("Query: %s %v\n", query.Name, query.Type)
		}
		bodies := GetNameType(decl, GOREAPI_BODY)
		for _, body := range bodies {
			fmt.Printf("Body: %v\n", body.Type)
		}
		responses := GetResponse(decl)
		for _, response := range responses {
			fmt.Printf("Response: %v\n", response.Type)
		}
		handler := GetHandler(decl)
		fmt.Printf("Handler: %v\n", handler)

		httpHandler := BuildHTTPHandler(name, params, queries, bodies, responses, handler)
		node.Decls = append(node.Decls, httpHandler)

		// remove the original handler
		ast.Inspect(node, func(n ast.Node) bool {
			if n == nil {
				return false
			}
			switch n := n.(type) {
			case *ast.GenDecl:
				for _, spec := range n.Specs {
					spec, ok := spec.(*ast.ValueSpec)
					if !ok {
						continue
					}
					if len(spec.Values) == 0 {
						continue
					}
					call, ok := spec.Values[0].(*ast.CallExpr)
					if !ok {
						continue
					}
					if !IsGoreAPIUsage(call.Fun) {
						continue
					}
					fun, ok := call.Fun.(*ast.SelectorExpr)
					if !ok {
						continue
					}
					if fun.Sel.Name != GOREAPI_HANDLER_DECL {
						continue
					}
					if spec.Names[0].Name == name {
						n.Specs = nil
						break
					}
				}
			}
			return true
		})
	}

	// Write the modified file
	f, err := os.Create(outputFile)
	if err != nil {
		log.Fatalf("Failed to create file: %v", err)
	}
	if err := printer.Fprint(f, token.NewFileSet(), node); err != nil {
		log.Fatalf("Failed to write file: %v", err)
	}
	if err := f.Close(); err != nil {
		log.Fatalf("Failed to close file: %v", err)
	}

	{
		file, _ := os.ReadFile(outputFile)
		lines := strings.Split(string(file), "\n")
		for _, decl := range handlerDeclarations {
			lines = append(
				lines,
				fmt.Sprintf("var %s = http.HandlerFunc(goreapi%s)", decl.name, decl.name),
			)
		}
		if err := os.WriteFile(outputFile, []byte(strings.Join(lines, "\n")), 0644); err != nil {
			log.Fatalf("Failed to write file: %v", err)
		}
	}

	{
		file, _ := os.ReadFile(outputFile)
		lines := strings.Split(string(file), "\n")
		if len(lines) >= 2 && lines[0] == "//go:build gore" && lines[1] == "// +build gore" {
			lines = lines[2:]
		}
		lines = append([]string{"//go:build !gore", "// +build !gore"}, lines...)
		for i, line := range lines {
			if strings.HasPrefix(line, "package ") {
				lines = append(lines[:i+1], append([]string{"import \"net/http\"", "import \"strconv\"", "import \"encoding/json\""}, lines[i+1:]...)...)
				break
			}
		}

		if err := os.WriteFile(outputFile, []byte(strings.Join(lines, "\n")), 0644); err != nil {
			log.Fatalf("Failed to write file: %v", err)
		}

		// run gofmt on the generated file
		if err := exec.Command("gofmt", "-w", outputFile).Run(); err != nil {
			log.Fatalf("Failed to run gofmt: %v", err)
		}
		// run goimports on the generated file
		if err := exec.Command("goimports", "-w", outputFile).Run(); err != nil {
			log.Fatalf("Failed to run goimports: %v", err)
		}
	}
	{

		file, _ := os.ReadFile(outputFile)
		lines := strings.Split(string(file), "\n")
		lines = append([]string{"// Code generated by goreapi. DO NOT EDIT."}, lines...)
		if err := os.WriteFile(outputFile, []byte(strings.Join(lines, "\n")), 0644); err != nil {
			log.Fatalf("Failed to write file: %v", err)
		}
	}
	fmt.Println("Generated file:", outputFile)
}

const (
	GOREAPI_PACKAGE      = "goreapi"
	GOREAPI_HANDLER_DECL = "H"
	GOREAPI_PARAM        = "Param"
	GOREAPI_QUERY        = "Query"
	GOREAPI_BODY         = "Body"
	GOREAPI_RESPONSE     = "Response"

	GOREAPI_BUILTIN_INT   = "Int"
	GOREAPI_BUILTIN_STR   = "String"
	GOREAPI_BUILTIN_BOOL  = "Bool"
	GOREAPI_BUILTIN_FLOAT = "Float"
	GOREAPI_BUILTIN_ANY   = "Any"
)

func IsGoreAPIBuiltinType(name string) bool {
	return name == GOREAPI_BUILTIN_INT ||
		name == GOREAPI_BUILTIN_STR ||
		name == GOREAPI_BUILTIN_BOOL ||
		name == GOREAPI_BUILTIN_FLOAT ||
		name == GOREAPI_BUILTIN_ANY
}

type Type struct {
	Package   string
	Name      string
	Builtin   string
	IsBuiltin bool
}

func (t Type) String() string {
	if t.IsBuiltin {
		switch t.Name {
		case GOREAPI_BUILTIN_INT:
			return "int"
		case GOREAPI_BUILTIN_STR:
			return "string"
		case GOREAPI_BUILTIN_BOOL:
			return "bool"
		case GOREAPI_BUILTIN_FLOAT:
			return "float64"
		default:
			log.Fatalf("Unknown builtin type: %s", t.Name)
		}
	}
	if t.Package != "" {
		return t.Package + "." + t.Name
	}
	return t.Name
}

type NameType struct {
	Name string
	Type Type

	ParseLogic string
}

func (nt NameType) GetParseLogic() string {
	if nt.Type.IsBuiltin {
		switch nt.Type.Name {
		case GOREAPI_BUILTIN_INT:
			return nt.Name + ", err = strconv.Atoi(data)"
		case GOREAPI_BUILTIN_STR:
			return nt.Name + " = data"
		case GOREAPI_BUILTIN_BOOL:
			return nt.Name + ", err = strconv.ParseBool(data)"
		case GOREAPI_BUILTIN_FLOAT:
			return nt.Name + ", err = strconv.ParseFloat(data, 64)"
		default:
			log.Fatalf("Unknown builtin type: %s", nt.Name)
		}
	}
	return "err = json.Unmarshal([]byte(data), &" + nt.Name + ")"
}

type Response struct {
	Type Type
}

type Handler struct {
	Args []struct {
		IsRef bool
		Name  string
	}
	Node *ast.FuncLit
}

func ReadFile(filename string) *ast.File {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Failed to parse file: %v", err)
	}
	return node
}

// BuildHTTPHandler builds the HTTP handler function from the given handler declaration.
func BuildHTTPHandler(
	name string,
	params []NameType,
	queries []NameType,
	bodies []NameType,
	responses []Response,
	handler *Handler,
) *ast.FuncDecl {
	htemplate := `
package tmp

func goreapi{{.Name}}(w http.ResponseWriter, r *http.Request) {
    // \/ --- INSERTED CODE --- \/
    handler := {{.Handler}}
    // /\ --- INSERTED CODE --- /\

    // Parse URL Query {{range .Queries}}
    var {{.Name}} {{.Type}}
    {
        // Parse {{.Name}} as {{.Type}} (isBuiltin: {{.Type.IsBuiltin}})
        var err error
        data := r.URL.Query().Get("{{.Name}}")
        {{.ParseLogic}}
        if err != nil {
            http.Error(w, err.Error() /*Here should be some prepared error*/, http.StatusBadRequest)
            return
        }
    }
    {{end}}
    // Parse URL parameter {{range .Params}}
    var {{.Name}} {{.Type}}
    {
        // Parse {{.Name}} as {{.Type}} (isBuiltin: {{.Type.IsBuiltin}})
        var err error
        data := r.PathValue("{{.Name}}")
        {{.ParseLogic}}
        if err != nil {
            http.Error(w, err.Error() /*Here should be some prepared error*/, http.StatusBadRequest)
            return
        }
    }
    {{end}}
    // Parse Body {{range .Bodies}}
    var {{.Name}} {{.Type}}
    {
        // Parse {{.Name}} as {{.Type}} (isBuiltin: {{.Type.IsBuiltin}})
        {{if .Type.IsBuiltin}}
        data := make([]byte, r.ContentLength)
        if _, err := r.Body.Read(data); err != nil {
            http.Error(w, err.Error() /*Here should be some prepared error*/, http.StatusBadRequest)
            return
        }
        {{.Name}}, err := {{.ParseLogic}}
        if err != nil {
            http.Error(w, err.Error() /*Here should be some prepared error*/, http.StatusBadRequest)
            return
        } {{else}}
        if err := json.NewDecoder(r.Body).Decode(&{{.Name}}); err != nil {
            http.Error(w, err.Error() /*Here should be some prepared error*/, http.StatusBadRequest)
            return
        }
        {{end}}
    }
    {{end}}
    // Call handler
    result := handler({{range .HandlerArgs}}
		{{if .IsRef}}&{{end}}{{.Name}},{{end}}
    )

    // Write response
    if err := json.NewEncoder(w).Encode(result); err != nil {
        http.Error(w, err.Error() /*Here should be some prepared error*/, http.StatusInternalServerError)
    }
}
`

	tmpl, err := template.New("handler").Parse(htemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}
	for i := range params {
		params[i].ParseLogic = params[i].GetParseLogic()
	}
	for i := range queries {
		queries[i].ParseLogic = queries[i].GetParseLogic()
	}
	for i := range bodies {
		bodies[i].ParseLogic = bodies[i].GetParseLogic()
	}
	data := map[string]interface{}{
		"Name":        name,
		"Params":      params,
		"Queries":     queries,
		"Bodies":      bodies,
		"Handler":     getNodeAsString(handler.Node),
		"HandlerArgs": handler.Args,
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, data); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	newHandler := buf.String()

	// Parse the generated handler
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, "", newHandler, parser.ParseComments)
	if err != nil {
		log.Fatalf("Failed to parse generated handler: %v", err)
	}

	// Extract the handler function
	var decl *ast.FuncDecl
	ast.Inspect(node, func(n ast.Node) bool {
		if n == nil {
			return false
		}
		switch n := n.(type) {
		case *ast.FuncDecl:
			decl = n
		}
		return true
	})
	if decl == nil {
		log.Fatalf("Failed to extract handler function from generated handler")
	}

	return decl
}

// GetHandlerName returns the name of the handler function in the given handler declaration.
func GetHandlerName(decl ast.Expr) string {
	var name string
	ast.Inspect(decl, func(n ast.Node) bool {
		if n == nil {
			return false
		}
		switch n := n.(type) {
		case *ast.Ident:
			name = n.Name
		}
		return true
	})
	return name
}

// GetNameType returns a list of all the goreapi.<nameTypeRequirer> calls in the given handler declaration.
func GetNameType(decl ast.Expr, nameTypeRequirer string) []NameType {
	params := []NameType{}
	ast.Inspect(decl, func(n ast.Node) bool {
		if n == nil {
			return false
		}
		switch n := n.(type) {
		case *ast.CallExpr:
			if !IsGoreAPIUsage(n.Fun) {
				return true
			}
			fun, ok := n.Fun.(*ast.SelectorExpr)
			if !ok {
				return true
			}
			if fun.Sel.Name == nameTypeRequirer {
				if len(n.Args) != 2 {
					log.Fatalf("Expected 2 arguments for Param, got %d", len(n.Args))
				}
				name := n.Args[0].(*ast.BasicLit).Value
				if name[0] == '"' && name[len(name)-1] == '"' {
					name = name[1 : len(name)-1]
				}
				params = append(params, NameType{
					Name: name,
					Type: GetGoreAPIType(n.Args[1]),
				})
			}
		}
		return true
	})
	return params
}

// GetResponse returns a list of all the goreapi.Response calls in the given handler declaration.
func GetResponse(decl ast.Expr) []Response {
	responses := []Response{}
	ast.Inspect(decl, func(n ast.Node) bool {
		if n == nil {
			return false
		}
		switch n := n.(type) {
		case *ast.CallExpr:
			if !IsGoreAPIUsage(n.Fun) {
				return true
			}
			fun, ok := n.Fun.(*ast.SelectorExpr)
			if !ok {
				return true
			}
			if fun.Sel.Name == GOREAPI_RESPONSE {
				if len(n.Args) != 1 {
					log.Fatalf("Expected 1 argument for Response, got %d", len(n.Args))
				}
				rawtyp := n.Args[0]
				responses = append(responses, Response{
					Type: GetGoreAPIType(rawtyp),
				})
			}
		}
		return true
	})
	return responses
}

// GetHandler returns the handler function of the given handler declaration.
func GetHandler(decl ast.Expr) *Handler {
	var node *ast.FuncLit
	ast.Inspect(decl, func(n ast.Node) bool {
		if n == nil {
			return false
		}
		switch n := n.(type) {
		case *ast.FuncLit:
			node = n
		}
		return true
	})

	if node == nil {
		return nil
	}

	// Extract arguments
	rargs := []struct {
		IsRef bool
		Name  string
	}{}
	for _, field := range node.Type.Params.List {
		args := map[string]bool{}
		for _, name := range field.Names {
			args[name.Name] = false
		}

		isRef := false
		switch field.Type.(type) {
		case *ast.StarExpr:
			isRef = true
		case *ast.Ident:
			isRef = false
		}
		for name := range args {
			args[name] = isRef
		}

		for name, asRef := range args {
			rargs = append(rargs, struct {
				IsRef bool
				Name  string
			}{
				IsRef: asRef,
				Name:  name,
			})
		}
	}
	return &Handler{
		Args: rargs,
		Node: node,
	}
}

// GetHandlerDeclarations returns a list of all the handler declarations in the given file.
// Look for function calls to goreapi.H.
func GetHandlerDeclarations(node *ast.File) []struct {
	name string
	node ast.Expr
} {
	decls := []struct {
		name string
		node ast.Expr
	}{}
	ast.Inspect(node, func(n ast.Node) bool {
		if n == nil {
			return false
		}
		switch n := n.(type) {
		case *ast.GenDecl:
			for _, spec := range n.Specs {
				spec, ok := spec.(*ast.ValueSpec)
				if !ok {
					continue
				}
				if len(spec.Values) == 0 {
					continue
				}
				call, ok := spec.Values[0].(*ast.CallExpr)
				if !ok {
					continue
				}
				if !IsGoreAPIUsage(call.Fun) {
					continue
				}
				fun, ok := call.Fun.(*ast.SelectorExpr)
				if !ok {
					continue
				}
				if fun.Sel.Name != GOREAPI_HANDLER_DECL {
					continue
				}
				decls = append(decls, struct {
					name string
					node ast.Expr
				}{
					name: spec.Names[0].Name,
					node: call,
				})
			}
		}
		return true
	})
	return decls
}

// IsGoreAPIUsage checks if the given expression uses the goreapi package.
func IsGoreAPIUsage(expr ast.Expr) bool {
	switch expr := (expr).(type) {
	case *ast.Ident:
		if expr.Name == GOREAPI_PACKAGE {
			return true
		}
	case *ast.SelectorExpr:
		return IsGoreAPIUsage(expr.X)
	case *ast.CallExpr:
		return IsGoreAPIUsage(expr.Fun)
	}
	return false
}

// GetGoreAPIType returns the goreapi type of the given expression.
// Allow only &<type>{}
func GetGoreAPIType(expr ast.Expr) Type {
	typ := Type{}
	switch expr := (expr).(type) {
	case *ast.UnaryExpr:
		if expr.Op != token.AND {
			displayExpr(expr)
			log.Fatalf("Unsupported goreapi type: %T", expr)
		}
		clist, ok := expr.X.(*ast.CompositeLit)
		if !ok {
			displayExpr(expr)
			log.Fatalf("Unsupported goreapi type: %T", clist)
		}
		if len(clist.Elts) != 0 {
			displayExpr(expr)
			log.Fatalf("Unsupported goreapi type: %T", expr)
		}
		switch t := clist.Type.(type) {
		case *ast.Ident:
			typ.Name = t.Name
		case *ast.SelectorExpr:
			typ.Package = t.X.(*ast.Ident).Name
			typ.Name = t.Sel.Name
			typ.IsBuiltin = false
			if x, ok := t.X.(*ast.Ident); ok && x.Name == GOREAPI_PACKAGE && IsGoreAPIBuiltinType(t.Sel.Name) {
				typ.IsBuiltin = true
			}
		default:
			displayExpr(expr)
			log.Fatalf("Unsupported goreapi type: %T", clist.Type)
		}
	default:
		displayExpr(expr)
		log.Fatalf("Unsupported goreapi type: %T", expr)
	}
	return typ
}
